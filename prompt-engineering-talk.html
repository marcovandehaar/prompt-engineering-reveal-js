<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"="width=device-width, initial-scale=1.0">
    <title>Prompt Engineering Debate</title>
    <link rel="stylesheet" href="https://unpkg.com/reveal.js@5.2.0/dist/reveal.css">
    <link rel="stylesheet" href="https://unpkg.com/reveal.js@5.2.0/dist/theme/night.css">
    <style>
        .reveal h1,
        .reveal h2 {
            color: #ffcc00;
            /* Gold for emphasis */
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.6);
        }

        .reveal h2.small {
            font-size: 1.1em;
        }

        .reveal h3.small {
            font-size: 1.1em;
        }

        .reveal h3 {
            color: #ffae00;
            /* Gold for emphasis */
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.6);
        }

        .reveal ul li {
            font-size: 1.2em;
            /* Slightly larger text */
            margin-bottom: 20px;
        }

        .reveal .slides section {
            background: linear-gradient(to bottom, #1e1e1e, #333333);
            /* Subtle gradient */
            color: #f0f0f0;
            padding: 40px 20px 20px 20px;
            /* Added top padding to make room for progress indicator */
            border-radius: 10px;
        }

        .reveal .slides section .background-image {
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            z-index: -1;
            /* Ensure it is behind the content */
        }

        .reveal p {
            font-size: 1.0em;
        }

        .reveal p.small {
            font-size: 0.8em;
        }

        .reveal div.small {
            font-size: 0.8em;
        }

        .reveal li {
            font-size: 1.0em;
        }

        .definition-box {
            border: 1px solid #ccc;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
        }

        .definition-box img {
            width: 50px;
            height: 50px;
            margin-right: 10px;
        }

        .definition-box p {
            margin: 0;
        }

        /* Progress indicator styles */
        .progress-container {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            height: 5px;
            background-color: rgba(255, 204, 0, 0.2);
            /* Subtle gold color */
            border-radius: 3px;
            z-index: 1000;
            pointer-events: none;
            /* So it doesn't interfere with clicks */
        }

        .section-name {
            position: absolute;
            top: 16px;
            /* 6px for the height of the progress bar + 10px margin */
            transform: translateX(-50%);
            font-size: 0.7em;
            color: rgba(255, 204, 0, 0.8);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 500;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .section-marker {
            position: absolute;
            top: 0;
            width: 10%;
            height: 100%;
            background-color: #ffae00;
            /* Orange accent color */
            border-radius: 3px;
            transition: left 0.6s ease;
        }

        /* Define positions for each section marker */
        body[data-section="intro"] .section-marker {
            left: 0%;
        }

        body[data-section="motion"] .section-marker {
            left: 20%;
        }

        body[data-section="syntax"] .section-marker {
            left: 40%;
        }

        body[data-section="knowledge"] .section-marker {
            left: 60%;
        }

        body[data-section="impact"] .section-marker {
            left: 80%;
        }

        body[data-section="closing"] .section-marker {
            left: 90%;
        }

        /* Show only the current section name */
        body[data-section="intro"] .section-name.intro,
        body[data-section="motion"] .section-name.motion,
        body[data-section="syntax"] .section-name.syntax,
        body[data-section="knowledge"] .section-name.knowledge,
        body[data-section="impact"] .section-name.impact,
        body[data-section="closing"] .section-name.closing {
            opacity: 1;
        }

        /* Position section names */
        .section-name.intro {
            left: 5%;
            top: 16px;
        }

        .section-name.motion {
            left: 25%;
            top: 16px;
        }

        .section-name.syntax {
            left: 45%;
            top: 16px;
        }

        .section-name.knowledge {
            left: 65%;
            top: 16px;
        }

        .section-name.impact {
            left: 85%;
            top: 16px;
        }

        .section-name.closing {
            left: 95%;
            top: 16px;
        }

        /* Add specific style for slides that need more space for the progress indicator */
        .reveal .prompt-example {
            margin-top: 15px;
            /* Add additional margin to the prompt example slides */
        }
    </style>
</head>

<body>
    <div class="reveal">
        <!-- Progress indicator -->
        <div class="progress-container">
            <div class="section-marker"></div>
            <div class="section-name intro">Intro</div>
            <div class="section-name motion">Motion</div>
            <div class="section-name syntax">Syntax</div>
            <div class="section-name knowledge">Knowledge</div>
            <div class="section-name impact">Impact</div>
            <div class="section-name closing">Closing</div>
        </div>

        <div class="slides">
            <!-- Slide 1: Title -->
            <section>
                <div class="r-vstack r-stretch">
                    <h2>"Is Prompt Engineering the Next Programming Language?"</h2>
                    <h3>An Oxford style debate</h3>
                    <p>Presented by <strong>Joris van Hien</strong> and <strong>Marco van de Haar</strong></p>
                </div>
                <aside class="notes">
                    <p>Joris: We’ll explore whether prompt engineering has evolved into a new form of programming or if
                        it's just a powerful communication skill with AI. Feel free to think about your own experiences
                        with ChatGPT or similar tools as we dive in!</p>
                </aside>
            </section>

            <section>
                <div class="background-image" style="background-image: url('assets/img/Hien1.jpg');">
                    <div class="r-vstack r-stretch">
                        <h2>Inspiration</h2>
                        <h3><strong>Hien Luu</strong></h3>
                        <div style="height: 300px;"></div>
                        <p>www.linkedin.com/in/hienluu</p>
                    </div>
                </div>
                <aside class="notes">
                    <p>Joris: Hien Luu is a senior engineering manager at DoorDash who emphasizes that we are in a “once
                        in a generation” shift with large language models. He posits prompt engineering might be the
                        next abstraction layer in software development. Keep his insights in mind as we debate!</p>
                </aside>
            </section>

            <section class="r-vstack r-stretch">
                <h2 class="small">Programming languages...</h2>
                <div class="r-stack">
                    <div class="fragment fade-in-then-out">
                        <p>Most have you have spent years....</p>
                        <ul>
                            <li>Studying syntax...</li>
                            <li>Understanding API's...</li>
                        </ul>
                        <img src="assets/img/code.png" alt="code" style="border-radius: 10px; width: 80%;">
                    </div>
                    <div class="fragment fade-in-then-out">
                        <div class="r-vstack">
                            <h3 class="small">Asking the right question!</h3>
                            <img src="assets/img/prompt.png" alt="code" style="border-radius: 10px;">
                        </div>
                    </div>
                </div>
                <aside class="notes">
                    Let’s take a moment to reflect on what many of us have invested years into — programming. We’ve
                    studied syntax, learned to use APIs, debugged, tested, optimized. These skills are built around
                    precision, control, and repeatability — the fundamentals of writing code that a machine can execute
                    the same way, every time.
                    <br /><br />
                    Now compare that to prompting. Instead of writing step-by-step instructions, we describe what we
                    want in natural language and hope the model understands what we mean.
                    <br /><br />
                    That shift — from defining exact behavior to describing intent — is powerful. But it’s also
                    fundamentally different.
                    <br /><br />
                    So while Hien calls prompt engineering “the most powerful language to learn,” the real debate today
                    is this:
                    Does prompt engineering meet the bar of a programming language — or is it something else entirely?
                </aside>

            </section>

            <section>
                <h2>Introduction</h2>
                <ul>
                    <li><strong>Purpose:</strong> Explore prompt engineering's significance</li>
                    <li><strong>Format:</strong> Oxford-style debate</li>
                </ul>
                <img src="assets/img/debate.png" alt="A debate!" style="border-radius: 10px; width: 80%;">
                <aside class="notes">
                    <p>
                        Marco:
                    <ul>
                        <li>So the goal is to explore whether prompt engineering could be considered a genuine
                            programming language</li>
                        <li>We’ll do this through an Oxford-style debate</li>
                        <li>We don’t aim to prove right or wrong, but by doing this debate, we hope to get you to form
                            your own opinion. </li>
                        <li>get you inspired and motivated to do something with this.</li>
                        <li>And we mean to inform. So At the end, I believe that most of the people here, will have
                            learned something new about prompt engineering.</li>
                    </ul>
                    </p>
                </aside>
            </section>

            <section>
                <div class="r-vstack r-stretch">
                    <h2>"Oxford style debate"</h2>
                    <p>A motion</p>
                    <p>Audience initial vote</p>
                    <p>Discussions</p>
                    <p>Closing arguments</p>
                    <p>Audience final vote</p>
                    <h3 class="small">Winner: Team with largest shift in audience votes</h3>
                </div>
                <aside class="notes">
                    <p>Marco: So what is an oxford style debate?</p>
                    <ul>
                        <li>We'll start with a motion, which we'll explain to you first.</li>
                        <li>Then we'll hold an initial vote, together with you guys. I'll explain more about this when
                            we get there.</li>
                        <li>After we voted, we'll start the discussion. there's be 2 sides: I will present arguments FOR
                            the motion, Joris will present arguments AGAINST the motion.</li>
                        <li>We'll close the discussion with passionate closing arguments, after which you can vote
                            again!</li>
                        <li>As I said, there is no right or wrong here, but the winner of the debate is the site with
                            the largest shift in votes.</li>
                    </ul>
                </aside>
            </section>

            <section>
                <div class="r-vstack r-stretch">
                    <h2>The Motion</h2>
                    <h3>Prompt engineering: A new programming language?</h3>
                </div>
                <aside class="notes">
                    <p>
                    <ul>
                        <li>Is prompt engineering truly the next programming language, or is it just fancy wordsmithing
                            for people who cannot write code?</li>
                        <li>To explore that, we first need to define both concepts.</li>
                    </ul>
                    </p>
                </aside>
            </section>
            <section>
                <div class="r-vstack r-stretch">
                    <div class="r-stack">
                        <img src="assets/img/proglang1.png" style="width: 100%;">
                        <img class="fragment" data-fragment-index="0" src="assets/img/proglang.gif" style="width: 100%;"
                            loop="false">
                    </div>
                </div>
                <aside class="notes">
                    <ul>
                        <li>So, what is a programming language?</li>
                        <li>Let's see what Claude thinks</li>
                        <li>a formal system of instructions .... humans use to communicate with computers....with a
                            defined syntax and semantics</li>
                        <li>Pretty clear right</li>
                    </ul>
                </aside>

                </aside>
            </section>

            <!--slide: what is prompt engineering-->
            <section>
                <div class="r-vstack r-stretch">
                    <h2>What is Prompt Engineering?</h2>
                    <div class="definition-box">
                        <img src="assets/img/claude.png" alt="Claude Logo">
                        <p class="small">Prompt engineering is the practice of crafting and optimizing inputs to AI
                            models to get more accurate, relevant, and useful outputs.</p>
                    </div>
                    <div class="definition-box">
                        <img src="assets/img/gpt.png" alt="ChatGPT Logo">
                        <p class="small">Prompt engineering is the process of crafting and refining input instructions
                            or queries to guide AI systems, like ChatGPT, toward producing the most accurate, relevant,
                            or creative responses.</p>
                    </div>
                </div>
                <aside class="notes">
                    <ul>
                        <li>Here we asked two major LLMs what prompt engineering is. The first one is Claude, by
                            Anthropic, the second one ChatGpt, by Openai.</li>
                        <li>The answers are Pretty similar,</li>
                        <li>Apart from the fact that ChatGPT apparently has a bigger EGO, finding it necessary to
                            mention itself.</li>
                    </ul>
                </aside>

                </aside>
            </section>

            <!-- Slide 4: Initial Vote -->
            <section>
                <h2>Initial Vote</h2>
                <p>Is prompt engineering the next programming language?</p>
                <button
                    style="font-size: 1.2em; padding: 10px; background-color: #ffcc00; border: none; border-radius: 5px;">Vote
                    Now</button>
                <aside class="notes">
                    <p>Joris: Let’s capture our baseline opinions now. Hien’s talk suggests many are intrigued by prompt
                        engineering’s power but unsure if it meets formal definitions. Let’s see where everyone stands
                        before we dive deep.</p>
                </aside>
            </section>

            <section>
                <div class="r-vstack r-stretch">
                    <h2>3 categories</h2>
                    <p>Syntax and Structure</p>
                    <p>Specialized Skills and Expertise</p>
                    <p>Impact and longevity</p>
                </div>
                <aside class="notes">
                    <p>Joris: We will structure debate in 3 categories, for which we will present arguments FOR and
                        AGAINST the motion.</p>
                </aside>
            </section>

            <!-- New Slide: Let the Debate Begin -->
            <section>
                <h2>Let the Debate Begin</h2>
                <div style="display: flex; justify-content: space-around; align-items: center;">
                    <div style="text-align: center;">
                        <h3>For</h3>
                        <img src="assets/img/marco-lego.png" alt="Marco" style="border-radius: 10px; width: 80%;">
                    </div>
                    <div style="text-align: center;">
                        <h3>Against</h3>
                        <img src="assets/img/joris-lego.png" alt="Joris" style="border-radius: 10px; width: 80%;">
                    </div>
                </div>
                <aside class="notes">
                    <p>Joris: The stage is set. One side sees the art and structure of prompting as the next frontier in
                        coding. The other sees it as more ephemeral and not quite “programming” in the strict sense.
                        Keep Hien’s arguments about the “missing pieces” in mind.</p>
                </aside>
            </section>

            <!-- Grouped Slides: Syntax and Structure (For) -->
            <section>
                <section>
                    <div class="r-vstack r-stretch">
                        <h2>Syntax and Structure</h2>
                        <h3>For the Motion</h3>
                        <ul>
                            <li>Prompt engineering requires structured syntax for optimal results</li>
                            <!--</hidden><li>Modular prompts enables reusability</li>-->
                            <li>Emerging best practices and patterns in prompt design </li>

                        </ul>
                    </div>
                    <aside class="notes">
                        <ul>
                            <li>The definition of a programming language was clear, it has a clear syntax and
                                structure..</li>
                            <li>I will present 2 arguments to convince you that prompt engineering, DOES require a clear
                                syntax and structure for optimal results.</li>
                        </ul>
                    </aside>
                </section>
                <section>
                    <div class="r-vstack r-stretch prompt-example" style="height: 100%;">
                        <h2>Prompt Structure</h2>
                        <div style="position: relative; width: 100%; height: 90%; margin-top: 20px;">
                            <!-- Vertical "PROMPT" label that appears in the final fragment -->
                            <div class="fragment fade-in" data-fragment-index="5"
                                style="position: absolute; left: -40px; top: 0; bottom: 0; width: 30px; display: flex; align-items: center; justify-content: center; z-index: 10;">
                                <div
                                    style="transform: rotate(-90deg); transform-origin: center center; background-color: rgba(70, 70, 70, 0.9); padding: 8px 20px; border-radius: 8px; font-weight: bold; color: white; white-space: nowrap; letter-spacing: 2px; box-shadow: 0 2px 10px rgba(0,0,0,0.2);">
                                    GOOD PROMPT</div>
                            </div>

                            <!-- Container for all the components -->
                            <div
                                style="position: relative; display: flex; flex-direction: column; width: 100%; height: 100%; gap: 10px;">
                                <!-- Role Component -->
                                <div class="fragment fade-in-then-semi-out" data-fragment-index="0"
                                    style="background-color: rgba(255, 235, 59, 0.2); border: 2px solid #ffeb3b; border-radius: 8px; padding: 10px;">
                                    <h3 style="margin: 0; color: #b3a429;">Role</h3>
                                </div>
                                <!-- Instruction Component -->
                                <div class="fragment fade-in-then-semi-out" data-fragment-index="1"
                                    style="background-color: rgba(200, 230, 201, 0.2); border: 2px solid #c8e6c9; border-radius: 8px; padding: 10px;">
                                    <h3 style="margin: 0; color: #55a558;">Instruction</h3>
                                </div>

                                <!-- Context Component -->
                                <div class="fragment fade-in-then-semi-out" data-fragment-index="2"
                                    style="background-color: rgba(187, 222, 251, 0.2); border: 2px solid #bbdefb; border-radius: 8px; padding: 10px;">
                                    <h3 style="margin: 0; color: #4285b4;">Context</h3>
                                </div>

                                <!-- Constraints & Guidelines Component -->
                                <div class="fragment fade-in-then-semi-out" data-fragment-index="3"
                                    style="background-color: rgba(255, 205, 210, 0.2); border: 2px solid #ffcdd2; border-radius: 8px; padding: 10px;">
                                    <h3 style="margin: 0; color: #c75b66;">Constraints & Guidelines</h3>
                                </div>

                                <!-- Output Format Component -->
                                <div class="fragment fade-in-then-semi-out" data-fragment-index="4"
                                    style="background-color: rgba(209, 196, 233, 0.2); border: 2px solid #d1c4e9; border-radius: 8px; padding: 10px;">
                                    <h3 style="margin: 0; color: #7b5cb5;">Output Format</h3>
                                </div>
                            </div>
                            <!-- Visual connection element that appears in the final fragment - a border that surrounds everything -->
                            <div class="fragment fade-in" data-fragment-index="5"
                                style="position: absolute; top: -10px; left: -10px; right: -10px; bottom: -10px; border: 3px dashed #555; border-radius: 15px; z-index: 5; pointer-events: none;">

                                <!-- Small arrows connecting the components -->
                                <div
                                    style="position: absolute; left: 50%; transform: translateX(-50%); top: 21%; height: 20px; width: 2px; background-color: #777;">
                                </div>
                                <div
                                    style="position: absolute; left: 50%; transform: translateX(-50%); top: 39%; height: 20px; width: 2px; background-color: #777;">
                                </div>
                                <div
                                    style="position: absolute; left: 50%; transform: translateX(-50%); top: 57%; height: 20px; width: 2px; background-color: #777;">
                                </div>
                                <div
                                    style="position: absolute; left: 50%; transform: translateX(-50%); top: 75%; height: 20px; width: 2px; background-color: #777;">
                                </div>
                            </div>
                        </div>

                        <!-- Final fragment to emphasize the complete prompt before moving to the next slide -->
                        <div class="fragment" data-fragment-index="6"
                            style="position: absolute; width: 1px; height: 1px; opacity: 0;"></div>
                    </div>
                    <aside class="notes">

                        <ul>
                            <li>See, you can ask an LLM anything. It'll answer any simple question you have. But, in order to improve the chance of getting anything useful, it's necessary to ask the right question. This requires structure</li>
                            <li>Let's explore that</li>
                            
                        </ul>

                    </aside>
                </section>

                <section>
                    <div class="r-vstack r-stretch">
                        <h2>Poorly written prompt</h2>
                        <div class="definition-box">
                            <p class="small">Explain how I can improve the performance of my application when retrieving
                                information from the database.</p>
                        </div>
                    </div>
                    <aside class="notes">
                       		This will get an answer, probably even a correct one, for some situations. But the chances that it will be useful for you, are very slim.
                    </aside>
                </section>
                <section name="good prompt">
                    <div class="r-vstack r-stretch small prompt-example">
                        <!-- Slide content wrapped in a fragment to allow revealing the entire prompt at the end -->
                        <div class="prompt-content">
                            <!-- Role -->
                            <div
                                style="position: relative; border: 2px solid #ffeb3b; padding: 5px; border-radius: 5px; margin-bottom: 5px;">
                                <div class="content">You are a performance optimization expert specializing in database
                                    queries and indexing strategies.</div>
                                <div class="label-overlay fragment fade-in-then-out"
                                    style="background: rgba(255,235,59,0.95); border-radius: 5px; border: 2px solid #ffeb3b; color: #333; position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; font-size: 1.3em; font-weight: bold;">
                                    <span class="prompt-section-label"
                                        style="padding: 0.5em 1.5em; border-radius: 8px; background: rgba(255,255,255,0.7); box-shadow: 0 2px 8px rgba(0,0,0,0.08);">Role</span>
                                </div>
                            </div>

                            <!-- Instruction -->
                            <div
                                style="position: relative; border: 2px solid #c8e6c9; padding: 5px; border-radius: 5px; margin-bottom: 5px;">
                                <div class="content">Explain how I can improve the performance of my application when
                                    retrieving information from the database.</div>
                                <div class="label-overlay fragment fade-in-then-out"
                                    style="background: rgba(200,230,201,0.95); border-radius: 5px; border: 2px solid #c8e6c9; color: #222; position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; font-size: 1.3em; font-weight: bold;">
                                    <span class="prompt-section-label"
                                        style="padding: 0.5em 1.5em; border-radius: 8px; background: rgba(255,255,255,0.7); box-shadow: 0 2px 8px rgba(0,0,0,0.08);">Instruction</span>
                                </div>
                            </div>

                            <!-- Context -->
                            <div
                                style="position: relative; border: 2px solid #bbdefb; padding: 5px; border-radius: 5px; margin-bottom: 5px;">
                                <div class="content">My application uses SQL Server with a large dataset containing
                                    millions of records. The most frequent queries involve searching, filtering, and
                                    joining multiple tables. The application experiences slow response times, especially
                                    under high concurrent load.</div>
                                <div class="label-overlay fragment fade-in-then-out"
                                    style="background: rgba(187,222,251,0.95); border-radius: 5px; border: 2px solid #bbdefb; color: #222; position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; font-size: 1.3em; font-weight: bold;">
                                    <span class="prompt-section-label"
                                        style="padding: 0.5em 1.5em; border-radius: 8px; background: rgba(255,255,255,0.7); box-shadow: 0 2px 8px rgba(0,0,0,0.08);">Context</span>
                                </div>
                            </div>

                            <!-- Constraints and Guidelines -->
                            <div
                                style="position: relative; border: 2px solid #ffcdd2; padding: 5px; border-radius: 5px; margin-bottom: 5px;">
                                <div class="content">Provide recommendations on indexing strategies, query optimization,
                                    caching techniques, and database schema design.</div>
                                <div class="label-overlay fragment fade-in-then-out"
                                    style="background: rgba(255,205,210,0.95); border-radius: 5px; border: 2px solid #ffcdd2; color: #222; position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; font-size: 1.3em; font-weight: bold;">
                                    <span class="prompt-section-label"
                                        style="padding: 0.5em 1.5em; border-radius: 8px; background: rgba(255,255,255,0.7); box-shadow: 0 2px 8px rgba(0,0,0,0.08);">Constraints
                                        & Guidelines</span>
                                </div>
                            </div>

                            <!-- Output Format -->
                            <div
                                style="position: relative; border: 2px solid #d1c4e9; padding: 5px; border-radius: 5px;">
                                <div class="content">Your response should include clear explanations, practical
                                    examples, and code snippets where applicable.</div>
                                <div class="label-overlay fragment fade-in-then-out"
                                    style="background: rgba(209,196,233,0.95); border-radius: 5px; border: 2px solid #d1c4e9; color: #222; position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; font-size: 1.3em; font-weight: bold;">
                                    <span class="prompt-section-label"
                                        style="padding: 0.5em 1.5em; border-radius: 8px; background: rgba(255,255,255,0.7); box-shadow: 0 2px 8px rgba(0,0,0,0.08);">Output
                                        Format</span>
                                </div>
                            </div>
                        </div>

                        <!-- Final fragment to pause before advancing to next slide -->
                        <div class="fragment"
                            style="position: absolute; top: 0; left: 0; width: 1px; height: 1px; opacity: 0;"></div>
                    </div>
                    <aside class="notes">
                        <p>..Now I'm not going to show you here, but the sheets will be available to everyone at the end, And I will cahllenge to try it yourself. far more effective.</p>
                        <p>even though prompting is very forgiving. using it effectively like this  is much like strict
                            syntax in programming languages.</p>
                    </aside>
                </section>

                <!--
                <section>

                    <h3>#2. Modular prompts enables reusability, similar to functions.</h3>
                    <div class="definition-box r-vstack r-stretch">
                        <p class="small" style="text-align: left;">Please translate the following text to English and
                            determine it's category: <span style="color: aqua;">"{{text}}"</span>.
                            Only use words a 10 year old could understand well.
                            Format your response as follows:
                            Category: (instruction, joke or other)
                            Translation: [the translation]</p>
                    </div>
                    <aside class="notes">
                        Argument number 2.
                        Encapsulate logic in functions, reusability.
                        same thing in prompt engineering too.
                    </aside>
                </section>

                <section>
                    <div class="r-vstack r-stretch">
                        <img src="assets/img/parameters.png" style="width: 90%;">
                    </div>
                </section>-->

                <section>
                    <div class="r-vstack r-stretch">
                        <h3>Argument #2.</h3>
                        <p>Emerging best practices and patterns in prompt design parallel those in programming
                            constructs.</p>
                    </div>
                </section>

                <section>
                    <div class="r-vstack r-stretch">
                        <h3>Prompting patterns and techniques</h3>
                        <ul>
                            <li>Few shots</li>
                            <li>Chain-of-thought</li>
                            <li>Tree-of-thought</li>
                        </ul>
                    </div>
                    <aside class="notes">
                        <ul>
                            <li>In recent years, researchers from companies like Google, OpenAI, and Meta have explored prompt patterns.</li>
                            <li>They found that structuring prompts in ways that align with AI learning capabilities increases the likelihood of relevant, insightful responses.</li>
                            <li>Some examples of these patterns include few-shot, chain-of-thought, and tree-of-thought prompting.</li>
                            <li>Look them up—interesting stuff!</li>
                            <li>I'll quickly dive into one of them: Chain of Thought.</li>
                        </ul>
                    </aside>

                    </aside>
                </section>

                <section>
                    <h2>Example: Chain of thought</h2>
                    <div class="r-vstack r-stretch">
                        <img src="assets/img/chainofthought.png">
                        <p class="small" style="text-align: right; margin-top: 10px;">Source: <a
                                href="https://research.google/blog/language-models-perform-reasoning-via-chain-of-thought/">Wej
                                et al. (2022)</a></p>
                    </div>
                    <aside class="notes">
                        <ul>
                            <li>Research from Google published in 2022 aimed to unlock reasoning capabilities in these models using very simple techniques.</li>
                            <li>Two funny things here: Joris and I decided to do this talk to share something cool we saw in SF back in November last year. My biggest fear was, seeing the sheer speed of developments in this field, that we would create a cool presentation that was hopelessly out of date.</li>
                            <li>We did our best to keep it up to date, but just as an example, the research you see mentioned here is from 2022. That’s stone age for AI.</li>
                            <li>But very interesting to share, because it's very illustrative of how we're researching AI.</li>
                            <li>So back in 2022, we're talking GPT 2.5 or something, and what they found out is that when you ask a complex question, it's often wrong. But just by telling it to think step by step, it'll give you the explanation how it got the answer, and get it right.</li>
                            <li>Much like how we humans would do this.</li>
                            <li>So, a patterned approach to solve a common problem, just like we often see in programming.</li>
                        </ul>
                    </aside>

                    </aside>
                </section>

                <section>
                    <h2>What about design patterns?</h2>
                    <div class="r-vstack r-stretch">
                        <img src="assets/img/promptpatterns.png">
                        <p class="small" style="text-align: right; margin-top: 10px;">Source: <a
                                href="https://arxiv.org/abs/2302.11382">White et al. (2023)</a></p>
                    </div>
                    <aside class="notes">
                        <ul>
                            <li>Patterned approached. So what about design patterns? All experienced software engineers in this room will be aware of design patterns like Factory, Strategy, Decorator, etc.</li>
                            <li>These also exist in prompt engineering. Research from Vanderbilt University in 2023 outlined 16 different prompt patterns—general approaches you can use to solve certain problems.</li>
                            <li>Let's look at one of my favorites: the "flipped interaction" pattern.</li>
                        </ul>

                    </aside>
                </section>

                <section>
                    <h2>Example: flipped interaction</h2>
                    <ul>
                        <li>For tasks you are not familliar with,</li>
                        <li>You might not even know what to ask?</li>
                        <li>But the Model probably does!</li>
                        <li>So let's ask it, what to ask!</li>
                    </ul>
                    <p class="small" style="text-align: right; margin-top: 10px;">Let's check this out....</p>
                    <aside class="notes">
                        <ul>
                        <li>Flipped interaction.</li>
                        <li>So, when prompting, you're probably used to asking questions and getting answers, right?</li>
                        <li>But what if you don’t know the questions?</li>
                        <li>What if you need an answer in a domain you know nothing about?</li>
                        <li>Let's check this out.</li>

                        </ul>

                        Prompt to use to demo flipped interaction:

                        I am a starting hobby beer brewer and have just bought a Grainfather G40 home brewing installation. I want to brew a west coast style IPA. I need help on which ingredients to use and help creating a recipe with temperatures and times for mashing and fermenting. Please ask the most important questions, one by one, until you have sufficient information to make a recommendation. it's my first time, so you can assume a lot.  I still have to learn all the technicalities of brewing, so please use common words. Once you have enough information, share your proposal.
                    </aside>
                </section>
            </section>

            <!-- Grouped Slides: Syntax and Structure (Against) -->
            <section>
                <section>
                    <div class="r-vstack r-stretch">
                        <h2>Syntax and Structure</h2>
                        <h3>Against the Motion</h3>
                        <ul>
                            <li>No formalized syntax or strict rules</li>
                            <li>Probabilistic outputs lead to inconsistent results</li>
                        </ul>
                    </div>
                    <aside class="notes">
                        Let’s now examine the case against the motion, starting with syntax and structure — the
                        foundation of any programming language.
                        <br /><br />
                        We just saw how prompting can benefit from structure — role, task, context, constraints. But
                        here’s the key difference: in programming, structure isn’t optional. It’s enforced by compilers,
                        interpreters, and formal grammars.
                        <br /><br />
                        Prompt engineering doesn’t have that. It operates in natural language — flexible, ambiguous, and
                        interpreted differently from one model to another.
                        <br /><br />
                        So while good prompt design might look structured on the surface, underneath, it behaves more
                        like conversation than code. And that matters — because structure without enforcement isn’t a
                        language, it’s a suggestion.
                    </aside>
                </section>

                <section>
                    <div class="r-vstack r-stretch">
                        <h3>When Good Prompts Go Bad</h3>
                        <div>
                            <p><strong>Prompt:</strong></p>
                            <div
                                style="font-size: 0.8em; border: 1px solid #666; padding: 1em; border-radius: 8px; background: #2b2b2b; color: #f1f1f1;">
                                <code>
                        Refactor this method to improve readability and performance without altering its behavior.<br/>
                        Use modern C# features and follow best practices for async code and exception handling.
                      </code>
                            </div>


                            <p style="margin-top: 1em;">
                                Sounds perfect, right? Clear intent, good structure,<br /> lots of detail…
                                <strong>Even the most careful prompt can hide a forest of assumptions.</strong>
                            </p>
                        </div>
                    </div>
                    <aside class="notes">
                        We just talked about how prompting lacks strict syntax or formal rules. This next example makes
                        that gap even more tangible.
                        <br /><br />


                        This is one of my favorite kinds of prompt — it looks so precise. It reads like something you’d
                        see in a code review, or a message to Copilot Chat. It feels like code, right? Specific.
                        Actionable. Professional.
                        <br /><br />


                        But the moment you look more closely, you realize how much of it is left to interpretation — not
                        just for an AI model, but even for experienced developers.
                        <br /><br />


                        Take each phrase in the prompt — what seems like a clear instruction quickly becomes debatable:
                        <br /><br />


                        <strong>“Readability”</strong> — for whom? Should I favor LINQ or traditional loops? Should I
                        use <code>var</code> or explicit types?
                        <strong>“Performance”</strong> — are we optimizing for CPU, memory, allocations, or async
                        throughput?
                        <strong>“Without altering behavior”</strong> — including side effects? Timing? Threading
                        implications?
                        <strong>“Modern C#”</strong> — which version? 8? 10? Are we allowed to use preview features from
                        12?
                        <strong>“Async best practices”</strong> — does that mean using <code>ConfigureAwait</code>,
                        cancellation tokens, <code>ValueTask</code>?
                        <strong>“Exception handling”</strong> — do we wrap, bubble, log, rethrow, or fail fast?
                        <br /><br />


                        The syntax of this prompt looks clean — but the semantics are squishy. And that’s the point.
                        When precision matters, this kind of ambiguity is exactly what separates prompting from
                        programming.
                    </aside>
                </section>
                <section>
                    <div class="r-vstack r-stretch">
                        <h2>Missing Typical Constructs</h2>
                        <div
                            style="font-size: 0.8em; border: 1px solid #666; padding: 1em; border-radius: 8px; background: #2b2b2b; color: #f1f1f1;">
                            You can’t build skyscrapers out of sticky notes
                        </div>

                        <ul style="margin-top: 1em;font-size: 0.55em;">
                            <li>❌ <strong>No functions:</strong> Can’t extract logic into reusable named steps</li>
                            <li>❌ <strong>No reusable variables:</strong> Can’t store intermediate results and reference
                                them later like code</li>
                            <li>❌ <strong>No control flow:</strong> Can’t chain or conditionally apply prompts</li>
                        </ul>

                        <p class="fragment" style="margin-top: 1.5em;">

                        </p>
                    </div>
                    <aside class="notes">
                        So we’ve seen how even a carefully worded prompt can fall apart under scrutiny — and this next
                        point shows just how deeply that limitation goes.
                        <br /><br />


                        Programming languages give us powerful constructs: functions, variables, conditionals. These
                        aren’t just nice to have — they’re what let us build complex, reliable systems by composing
                        smaller pieces of logic.
                        <br /><br />


                        But in prompt engineering, that composability is missing. You can’t extract a reusable piece of
                        logic and apply it elsewhere. There’s no way to define a named function, pass in arguments, or
                        return structured values.
                        <br /><br />


                        You also can’t store and reuse intermediate results — there's no state, no scope. The model
                        might "remember" what you just said, or it might reinterpret it based on new context.
                        <br /><br />


                        And control flow? There’s no “if this, then that.” You can’t chain behavior or introduce logic.
                        Every prompt is a new guess — not a continuation of a deterministic process.
                        <br /><br />


                        That’s what the sticky note metaphor is about. Each prompt feels self-contained, disconnected.
                        You can write a brilliant one — but you can’t build on it. And without modularity, there’s no
                        real foundation for building scalable systems.
                    </aside>


                </section>

                <section>
                    <div class="r-vstack r-stretch">
                        <h2>Unpredictability</h2>
                        <ul>
                            <li>Outputs can vary from run to run</li>
                            <li>Hard to guarantee deterministic behavior</li>
                            <li>Relies on model’s training data and random sampling</li>
                        </ul>
                    </div>
                    <aside class="notes">
                        <p>The point is that we can't rely on predictable results. Without determinism, it’s tough to
                            have the same confidence we have in compiled code or well-defined interpretive languages.
                            The language model might guess differently next time!</p>
                    </aside>
                </section>
                <section>
                    <div class="r-vstack r-stretch">

                        <p>Even basic programming prompts yield inconsistent code:</p>

                        <div style="font-size: 0.85em; border-left: 3px solid #888; padding-left: 1em;">
                            <strong>Prompt:</strong> <code>Write a C# method that validates an email address.</code>
                        </div>

                        <ul style="margin-top: 1em; font-size: 0.65em">
                            <li class="fragment"> Regex-based — good, but brittle</li>
                            <li class="fragment"> MailAddress try-catch System.Net.Mail.MailAddress — legit, but
                                overkill?</li>
                            <li class="fragment"> Naive check — <code>Contains("@")</code> and <code>"."</code> 😬</li>
                            <li class="fragment">Style and error handling vary every time</li>
                        </ul>

                        <p class="fragment" style="margin-top: 1.5em;"><strong>Same input. Different code. No
                                guarantees.</strong></p>
                    </div>
                    <aside class="notes">
                        In programming, determinism is essential — you want the same code from the same instruction.
                        <br /><br />
                        But when prompting an LLM, you get variation — sometimes subtle, sometimes critical.
                        <br /><br />
                        It might choose regex, or the MailAddress class, or just check for "@" — you have no way to
                        control the approach unless you spell out every detail.
                        <br /><br />
                        That’s not programming. That’s guessing. That’s not a language. That’s an interface to a
                        probability engine.

                        <p>The point is that we can't rely on predictable results. Without determinism, it’s tough to
                            have the same confidence we have in compiled code or well-defined interpretive languages.
                            The language model might guess differently next time!</p>
                    </aside>
                </section>
            </section>

            <!-- Grouped Slides: Knowledge and Expertise (For) -->
            <section>
                <section>
                    <div class="r-vstack r-stretch">
                        <h2>Knowledge and Expertise</h2>
                        <h3>For the Motion</h3>
                        <div class="small">
                            <ul>
                                <li>Requires understanding AI model workings</li>
                                <li>Learning curve comparable to programming languages</li>
                                <li>Advanced applications like RAG and agents</li>
                            </ul>
                        </div>
                    </div>
                    <aside class="notes">
                        
                    <ul>                        
                        <li>onto the next category, knowledge and expertise.</li>
                        <li>Effective prompt engineering requires understanding AI model workings</li>
                        <li>Prompt engineering has a learning curve, comparable to programming languages</li>
                        <li>Advanced applications, comparable to programming architectures, like RAG and agents build on prompt engineering</li>
                    </ul>

                    </aside>
                </section>
                <section>
                    <div class="r-vstack r-stretch">
                        <h2>Next Token Generator</h2>
                        <div class="r-vstack r-stretch">
                            <img src="assets/drawio/next-token-generator.svg">
                        </div>
                    </div>
                    <aside class="notes">
                        <ul>
                            <li>Mastering prompt engineering requires some knowledge of what happens under the hood, similar to programming languages.</li>
                            <li>High-level language features might make it easier to write code, but you need to understand what happens on lower levels to use it effectively (e.g., how async handles threads).</li>
                            <li>The same is true for prompt engineering.</li>
                            <li>Let's talk a little bit about how AI models work.</li>
                            <li>Some of the most well-known AI models now are what we call "next token generators."</li>
                        </ul>
                    </aside>
                    </aside>
                </section>
                <section>
                    <div class="r-vstack r-stretch">
                        <h2>#1 Specialized knowledge</h2>
                        <h3>Tuning parameters</h3>
                        <p><span style="color: aqua;">Sampling options</span> and <span
                                style="color: aqua;">Temperature</span></p>
                        <p>Demo: Effects of prompt parameters (e.g., temperature)</p>
                    </div>
                    <aside class="notes">
                        <ul>
                           		<li>Let's dive a little bit deeper. Because, if it's always as random as this, model wouldn’t be very useful.</li>
	                            <li>So there are some tuning knobs you can tweak to modify how the model generates an answer. </li>
                                    <li>Think of temperature as a dial to set how creative the model needs to be.</li>
	                            <li>Sampling methods are a way to limit the number of possible answers it considers.</li>
	                            <li> Let's look at a small example. The temperature adjusts the probability distribution through a mathematical function. When the temperature is low, the probability gap between words widen, favoring the high probability words. When the temperature is high, the probability distribution becomes more even, giving lower probability words a better chance of being selected.</li>
	                            <li>A good analogy is, that at a  lower temperature, the a.i. model acts like a baker who follows the recipy exactly, step by st. And at higher temperature, the model acts like a wild experimental chef, throwing together ingredients, hoping that it will taste good</li>
                                <li> Top-P acts like a filter or a window. When the value is high, the window size is larger, so allow more words to come in, to be selected as the next word, and vice versa, when it's low and it's narrow, so less words will get in. This will become more clear when we go into a demo.</li>
                                

                        </ul>
                    </aside>
                </section>
                <section>
                    <div class="r-vstack r-stretch">
                        <h2>#2 Learning curve</h2>
                        <p>A learning curve that parallels learning a programming language</p>
                        <p class="small">The prompt report</p>
                    </div>
                </section>
                <section>
                    <div class="r-vstack r-stretch">
                        <img src="assets/img/promptingtechniques.png" style="width: 90%; margin: auto;">
                        <div style="display: flex; justify-content: space-between; margin-top: 10px;">
                            <div class="definition-box"
                                style="flex: 1; margin-right: 10px; text-align: center; color: #ffcc00;">
                                <p>1565 papers</p>
                            </div>
                            <div class="definition-box"
                                style="flex: 1; margin-left: 10px; text-align: center; color: #ffcc00;">
                                <p>~100 prompting techniques</p>
                            </div>
                        </div>
                    </div>
                    <aside class="notes">
                        <ul>
                            <li>Prompt techniques are diverse and evolving.</li>
                            <li>This report from OpenAI and Microsoft was published in 2024.</li>
                            <li>They conducted a literature review of over 1,500 prompt engineering related papers, analyzing different kinds of techniques.</li>
                            <li>The point here is that mastering prompt engineering is not just about using natural language.</li>
                            <li>There are numerous techniques, and as software engineers, we must learn or figure out how to best apply them in our specific use cases—just like using a programming language.</li>
                        </ul>
                        </ul>
                </section>
                <section>
                    <div class="r-vstack r-stretch">
                        <h2>#3 Evolution!</h2>
                        <p>How we interact with these models evolves!</p>
                        <div class="small">
                            <ul>
                                <li>
                                    Reasoning models, deep research
                                </li>
                                <li>
                                    RAG
                                </li>
                                <li>
                                    Agentic A.I.
                                </li>
                            </ul>
                        </div>
                    </div>
                    <aside class="notes">
                        <ul>
                            <li>How we interact with AI is evolving—just like programming languages did.</li>
                            <li>Reasoning models are advancing: not just answering questions, but understanding intent more deeply.</li>
                            <li>Complex architectures are emerging, such as:
                                <ul>
                                    <li><strong>RAG (Retrieval-Augmented Generation):</strong> Adds external context to improve responses.</li>
                                    <li><strong>Agentic AI:</strong> Enables autonomous, multi-step reasoning and task execution.</li>
                                </ul>
                            </li>
                           
                        </ul>

                        </ul>
                    </aside>
                </section>
                <section>
                    <div class="r-vstack r-stretch">
                        <img src="assets/img/agentic.gif">
                    </div>
                        <aside class="notes">
                        <ul>
                            <li>At the core of these systems are prompts—prompts that are reviewed, tested (even as units), and versioned.</li>
                            <li>Just like source code in programming languages.</li>
                        </ul>
                    </aside>
                </section>

            </section>

            <!-- Grouped Slides: Knowledge and Expertise (Against) -->
            <section>
                <section>
                    <div class="r-vstack r-stretch">
                        <h2>Knowledge and Expertise</h2>
                        <h3>Against the Motion</h3>
                        <ul>
                            <li>Natural language lowers the barrier to entry</li>
                            <li>Lacks the complexity of traditional programming</li>
                            <li>Relies heavily on communication skills</li>
                        </ul>
                    </div>
                    <aside class="notes">
                        This is one of the most fundamental differences between prompt engineering and traditional
                        programming.
                        <br /><br />
                        Programming requires deep understanding of algorithms, data structures, runtime behavior, error
                        handling — it’s logic-first, system-first.
                        <br /><br />
                        Prompt engineering? It’s closer to crafting a sentence than defining a system. It requires
                        empathy, tone, and clarity — not compilation and control flow.
                        <br /><br />
                        There's no strict syntax, no type system, no tooling for step-through debugging. Even experts
                        are operating in a space of uncertainty and interpretation.
                        <br /><br />
                        So while you can *get better* at prompting, you don't need — or even use — the skillset that
                        defines formal programming.
                    </aside>
                </section>

                <section>
                    <div class="r-vstack r-stretch">
                        <h2>Fewer Prerequisites</h2>
                        <div
                            style="font-size: 0.8em; border: 1px solid #666; padding: 1em; border-radius: 8px; background: #2b2b2b; color: #f1f1f1;">
                            Prompting isn’t writing logic. It’s making suggestions to a genie and hoping it understands
                            your tone.
                        </div>
                        <ul style="font-size: 0.65em; margin-top: 1.5em;">
                            <li>🧠 <strong>No need for algorithms or data structures</strong> — You don’t implement
                                mergesort to write a good prompt.</li>
                            <li>💬 <strong>Clarity beats cleverness</strong> — It’s more about expressing intent than
                                optimizing logic.</li>
                            <li>🎯 <strong>You ask questions, not define behavior</strong> — It’s persuasion, not
                                precision.</li>
                        </ul>
                    </div>
                    <aside class="notes">
                        This is where prompt engineering really shows its colors.
                        <br /><br />
                        You don’t need to know how memory works, or how to optimize a loop. You just need to describe
                        your goal well — like explaining it to a smart but unpredictable intern.
                        <br /><br />
                        That’s why prompting leans on communication skills, not technical depth. The model doesn’t need
                        strict syntax — it needs clarity, tone, framing.
                        <br /><br />
                        It’s not about building algorithms — it’s about nudging a black box in the right direction.
                    </aside>
                </section>
                <section>
                    <div class="r-vstack r-stretch">
                        <h3>Understanding ≠ Programming the Model</h3>
                        <ul style="font-size: 0.65em; margin-top: 0.5em;">
                            <li>📘 Understanding how LLMs work helps — but it’s not programming them</li>
                            <li>🎛️ Prompting is about influencing output, not controlling execution</li>
                            <li>🧠 Model behavior is statistical, not deterministic — you don’t write code, you shape
                                probability</li>
                        </ul>
                        <p class="fragment" style="margin-top: 1.5em;">
                            <strong>Knowing how a language model works doesn’t mean you’re writing in a
                                language.</strong>
                        </p>
                    </div>
                    <aside class="notes">
                        One of the common arguments for the motion is that “prompt engineering requires deep
                        understanding of how LLMs work.”
                        <br /><br />
                        And sure — knowing about transformers, tokenization, or sampling strategies can help you write
                        better prompts. But that doesn’t mean you’re programming the model.
                        <br /><br />
                        Programming means defining behavior. It means writing instructions that are executed in a
                        controlled, repeatable way.
                        <br /><br />
                        Prompting doesn’t give you that. You’re not programming — you’re influencing. You’re steering a
                        black box that generates text based on probability, not logic flow.
                        <br /><br />
                        So yes, understanding the model matters. But that’s like saying “understanding a microwave makes
                        you an electrical engineer.” It helps — but it’s not the same thing.
                    </aside>
                </section>
                <section>
                    <div class="r-vstack r-stretch">
                        <h2>Tuning Parameters</h2>


                        <ul style="font-size: 0.65em; margin-top: 1.5em;">
                            <li>🎛️ Temperature doesn’t define logic — it shapes personality</li>
                            <li>🎲 Same prompt, different mood — no consistent behavior</li>
                            <li>🧱 Programming means control — this is suggestion + luck</li>
                        </ul>

                    </div>
                    <aside class="notes">
                        Let’s look at what happens when we run the exact same prompt — something simple and
                        well-defined: "Write a function that returns the nth Fibonacci number."
                        <br /><br />
                        At temperature 0, we get a clean, iterative implementation. It's minimal, predictable, and
                        exactly what most developers would expect.
                        <br /><br />
                        But at temperature 1? The model might go recursive, add commentary, memoization, or even switch
                        languages entirely. One version might use LINQ. Another might give you an object-oriented class.
                        <br /><br />
                        This is the point. You can tweak the model’s behavior, but you're not writing deterministic
                        logic — you're steering a probability engine.
                        <br /><br />
                        Programming gives you guarantees. Prompting gives you options, interpretations, and occasionally
                        surprises.
                    </aside>
                </section>
                <section>
                    <div class="r-vstack r-stretch">
                        <h2>Tuning Parameters</h2>


                        <div
                            style="margin-top: 2em; font-size: 0.65em; border-left: 3px solid #888; padding-left: 1em;">
                            <strong>Prompt:</strong><br />
                            <code>Write a function that returns the nth Fibonacci number.</code>
                        </div>

                        <ul style="margin-top: 1em; font-size: 0.55em;">
                            <li class="fragment">🧊 <strong>Temp 0.0:</strong> Iterative function, clean, minimal,
                                accurate</li>
                            <li class="fragment">🔥 <strong>Temp 1.0:</strong> Recursive version, maybe with comments,
                                or “for fun” in Python instead of C#</li>
                        </ul>

                        <p class="fragment" style="margin-top: 1.5em;font-size: 0.55em;">
                            <strong>You’re managing creative entropy.</strong>
                        </p>

                    </div>
                    <aside class="notes">
                        Let’s look at what happens when we run the exact same prompt — something simple and
                        well-defined: "Write a function that returns the nth Fibonacci number."
                        <br /><br />
                        At temperature 0, we get a clean, iterative implementation. It's minimal, predictable, and
                        exactly what most developers would expect.
                        <br /><br />
                        But at temperature 1? The model might go recursive, add commentary, memoization, or even switch
                        languages entirely. One version might use LINQ. Another might give you an object-oriented class.
                        <br /><br />
                        This is the point. You can tweak the model’s behavior, but you're not writing deterministic
                        logic — you're steering a probability engine.
                        <br /><br />
                        Programming gives you guarantees. Prompting gives you options, interpretations, and occasionally
                        surprises.
                    </aside>
                </section>
            </section>
            <!-- Grouped Slides: Impact and Longevity (For) -->
            <section>
                <section>
                    <div class="r-vstack r-stretch">
                        <h2>Impact and Longevity</h2>
                        <h3>For the Motion</h3>
                        <ul>
                            <li>Universal A.I. Adaption</li>
                            <li>Protocols</li>
                        </ul>
                    </div>
                    <aside class="notes">
                        <li>Impact and longevity, where we will be exploring whether this is A Paradigm shift in
                            human-computer interaction</li>
                        <li>Or just a fleeting trend???</li>
                    </aside>
                </section>
                <!--
                <section>
                    <div class="r-vstack r-stretch">
                        <h3>The future of programming?</h3>
                        <img src="assets/img/andrej.png" alt="Andrej Karpathy Tweet"
                            style="width: 90%; border-radius: 5px; margin: auto;">
                    </div>
                </section>-->
                <section>
                    <div class="r-vstack r-stretch">
                        <h3>Explosion of A.I. centered dev tooling</h3>
                        <div
                            style="display: flex; flex-direction: column; gap: 10px; margin-top: 20px; max-width: 800px; margin-left: auto; margin-right: auto;">
                            <!-- First row: 3 images -->
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
                                <img src="assets/img/assistants/blackbox.png" alt="Blackbox AI"
                                    style="width: 80%; border-radius: 5px; margin: auto;">
                                <img src="assets/img/assistants/bolt.png" alt="Bolt"
                                    style="width: 80%; border-radius: 5px; margin: auto;">
                                <img src="assets/img/assistants/codewhisperer.png" alt="CodeWhisperer"
                                    style="width: 80%; border-radius: 5px; margin: auto;">
                            </div>
                            <!-- Second row: 4 images -->
                            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px;">
                                <img src="assets/img/assistants/cody.png" alt="Cody"
                                    style="width: 80%; border-radius: 5px; margin: auto;">
                                <img src="assets/img/assistants/continue.png" alt="Continue"
                                    style="width: 80%; border-radius: 5px; margin: auto;">
                                <img src="assets/img/assistants/copilot.png" alt="Copilot"
                                    style="width: 80%; border-radius: 5px; margin: auto;">
                                <img src="assets/img/assistants/cursor.jpg" alt="Cursor"
                                    style="width: 80%; border-radius: 5px; margin: auto;">
                            </div>
                            <!-- Third row: 3 images -->
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
                                <img src="assets/img/assistants/devin.png" alt="Devin"
                                    style="width: 80%; border-radius: 5px; margin: auto;">
                                <img src="assets/img/assistants/tabnine.png" alt="TabNine"
                                    style="width: 80%; border-radius: 5px; margin: auto;">
                                <img src="assets/img/assistants/windsurf.png" alt="Windsurf"
                                    style="width: 80%; border-radius: 5px; margin: auto;">
                            </div>
                        </div>
                    </div>
                    <aside class="notes">
                        <ul>
                            <li>Just curious. If you're a developer, raise your hand. Now, who of you regularly uses some kind of AI tool to assist you in software engineering?</li>
                            <li>A survey from the Pragmatic Engineer (2024) found that 75% of developers use some kind of AI tool for software engineering related work.</li>
                            <li>It's hard to believe that it was only 2.5 years ago, November 2022, that ChatGPT was released to the world.</li>
                            <li>By now, the world is being flooded with AI tooling for software engineers, where you can prompt to develop your software.</li>
                            <li>There are new parties like Cursor, Windsurf, and Devin who center around the concept, but also traditional parties like GitHub Copilot and JetBrains are pivoting towards some kind of AI assistance.</li>                            
                        </ul>

                        </ul>
                    </aside>
                </section>

                <section>
                    <div class="r-vstack r-stretch">
                        <h3>Example: Windsurf editor</h3>
                        <img src="assets/img/assistants/windsurf_lg.png" alt="Windsurf"
                            style="width: 400px; margin: 20px auto; display: block;">
                        <div style="display: flex; justify-content: center; gap: 20px; margin-top: 20px;">
                            <button data-preview-video="assets/video/windsurf1.mp4"
                                style="padding: 10px 20px; background: #ffcc00; border: none; border-radius: 5px; cursor: pointer;">Video:
                                giving context...</button>
                            <button data-preview-video="assets/video/windsurf2.mp4"
                                style="padding: 10px 20px; background: #ffcc00; border: none; border-radius: 5px; cursor: pointer;">Video:
                                A.I. coding</button>
                        </div>
                    </div>
                    <aside class="notes">
                        <li>Let's look at an example. This is Windsurf, a fork of VS Code centered around AI-assisted development.</li>
                        <li>I've opened this presentation you are watching right now. It was made in Reveal.js and mostly built using tools like this.</li>
                        <li>One of the most annoying things I run into every time I try to code using AI is that it has difficulty understanding the context it's working in. These new tools are way better at this—so good that you can just ask it for the context.</li>
                        <li>Now, let's add a feature. I'll continue the thread and ask it how I can deploy this presentation to an Azure Static Website.</li>
                        <li>I've given instructions to a computer to alter my software, just like a programming language.</li>

                        </ul>
                </section>

                <section>
                    <div class="r-vstack r-stretch">
                        <h3>These systems are maturing.</h3>
                        <ul>
                            <li>MCP - Model Context Protocol</li>
                            <li>A2A - Agent to Agent protocol TODO</li>
                        </ul>
                        <p class="small" style="text-align: right; margin-top: 10px;">Source: <a
                                href="https://www.newsletter.swirlai.com/p/mcp-vs-a2a-friends-or-foes/">MCP vs. A2A:
                                Friends or Foes?. (2025)</a></p>
                    </div>
                    <aside class="notes">
                        <ul>
                            <li>A.I. software is maturing every day.</li>
                            <li>Protocols are being designed to standardize communication between A.I. applications.</li>
                            <li>MCP (Model Context Protocol) provides a standard way for A.I. systems to access data sources—very useful for dev tooling.</li>
                            <li>For example, with an MCP server linked to your test database, you could ask GitHub Copilot to consider your database structure when helping you code.</li>
                            <li>Google released the A2A protocol to standardize communication between autonomous agentic applications.</li>
                            <li>The key point: we're already designing protocols for A.I., just like we did with SOAP and REST.</li>
                        </ul>

                        </ul>
                    </aside>
                </section>

            </section>

            <!-- Grouped Slides: Impact and Longevity (Against) -->
            <section>
                <section>
                    <div class="r-vstack r-stretch">
                        <h2>Impact and Longevity</h2>
                        <h3>Against the Motion</h3>
                        <div style="font-size: 0.85em">
                            <ul>
                                <li>Prompting is a trend, not a transformation</li>
                                <li>AI progress could make prompting obsolete</li>
                                <li>Programming remains essential for control and scale</li>
                            </ul>
                        </div>
                    </div>
                    <aside class="notes">
                        As we move into the final part of our argument — impact and longevity — let’s step back and ask:
                        is this a temporary skill, or the foundation of future development?
                        <br /><br />
                        There’s reason to believe prompt engineering is a phase — not a paradigm. We’ve seen waves like
                        this before: visual programming, low-code platforms, natural language interfaces. Many looked
                        promising, but ultimately faded or were absorbed into tooling.
                        <br /><br />
                        What makes programming languages so durable is that they provide precision, abstraction, and
                        control — the things you need when building complex, large-scale systems. Prompt engineering, on
                        the other hand, is mostly about adapting to the quirks of today’s models.
                        <br /><br />
                        And that’s key: as models improve, the need for carefully crafted prompts will likely shrink.
                        Which means prompt engineering may never grow into a fully fledged language — it may just be a
                        useful tool for now.
                    </aside>
                </section>

                <section>
                    <div class="r-vstack r-stretch">
                        <h2>Obsolescence by Design?</h2>
                        <div style="font-size: 0.85em">
                            <ul>
                                <li>LLMs are improving at interpreting vague input</li>
                                <li>Future models may require less prompt "engineering"</li>
                                <li>Prompting could be absorbed into broader tooling</li>
                            </ul>
                        </div>
                    </div>
                    <aside class="notes">
                        Prompt engineering today exists because language models still need help. They need scaffolding —
                        structured input, clearly framed context, layered instruction.
                        <br /><br />
                        But as models grow more advanced, their ability to interpret vague or imprecise requests will
                        improve. In fact, we’re already seeing this shift. The newer generation of models can handle
                        more ambiguous queries with less guidance.
                        <br /><br />
                        The irony is: the better the models become, the less we need to engineer prompts. What we call
                        "prompt engineering" today could eventually disappear — absorbed into the interface layer or
                        handled automatically by systems.
                        <br /><br />
                        That’s not the trajectory of a new programming language. That’s a temporary workaround being
                        made obsolete by the technology itself.
                    </aside>
                </section>

                <section>
                    <div class="r-vstack r-stretch">
                        <h2>We Still Need Code</h2>
                        <div style="font-size: 0.85em">
                            <ul>
                                <li>Prompting can't replace programming for critical systems</li>
                                <li>Performance, reliability, and scale demand code</li>
                                <li>AI still relies on human-authored infrastructure</li>
                            </ul>
                        </div>
                    </div>
                    <aside class="notes">
                        Even if prompt engineering continues to evolve, it’s not replacing software engineering.
                        <br /><br />
                        Complex systems — operating systems, real-time applications, secure backend infrastructure — all
                        require precision. These can’t be built on natural language. They require structured logic,
                        deterministic behavior, and full control.
                        <br /><br />
                        Prompts might assist, but they don’t replace the core. And if they don’t replace it, they’re not
                        a new language — they’re a layer on top of one.
                        <br /><br />
                        In the end, prompting is useful — but programming remains essential.
                    </aside>
                </section>
            </section>

            <!-- Slide 13: Closing Arguments -->

            <!-- Main Closing Arguments Slide -->
            <section>
                <div class="r-vstack r-stretch"></div>
                <h2>Closing Arguments</h2>
                <div style="display: flex; justify-content: space-around; align-items: center;">
                    <img src="assets/img/closing3.png" alt="code" style="border-radius: 10px;">
                </div>
            </section>
            <aside class="notes">
                <p>Hien’s conclusion was that prompt engineering is not yet a programming language in the
                    traditional sense, but it’s definitely an emerging paradigm. Think about whether the arguments
                    you’ve heard sway you toward a future formal “prompt language” or remain unconvinced.</p>
            </aside>
            </section>
            <section>
                <!-- For the Motion - Vertical Slides -->
                <section>
                    <div class="r-vstack r-stretch">
                        <h2>Closing Arguments</h2>
                        <h3>For the Motion</h3>
                        <ul>
                            <li>Prompt engineering is evolving into a structured discipline</li>
                            <li>Clear patterns and best practices are emerging</li>
                            <li>Growing ecosystem of tools and frameworks</li>
                        </ul>
                    </div>
                    <aside class="notes">
                        <ul>
                            <li>Prompt engineering is the new programming language of the future. Like traditional programming, prompting will require careful structure, precision, and an understanding of the underlying system.</li>
                            <li>Prompt engineering has evolved beyond mere suggestions into a structured language with its own syntax, patterns, and specialized expertise. From Chain-of-Thought to RAG to agentic systems, we're building complex computational systems through the power of well-crafted prompts.</li>
                            <li>Just as programming languages evolved before, from punched cards, to functions, to object orientation and beyond, we now stand at the threshold of the next great paradigm shift.</li>
                            <li>The evidence is clear—as AI tools multiply and companies invest millions upon millions, prompt engineering isn't just knocking at the door of programming languages; it has already walked through and taken a seat at the table.</li>
                        </ul>
                    </aside>

                    </aside>
                </section>

                <section>
                    <div class="r-vstack r-stretch">
                        <h2>Vote for the Future!</h2>

                        <p>Vote for the next paradigm shift in software development!</p>


                    </div>
                </section>
            </section>
            <section>
                <!-- Against the Motion - Vertical Slides -->

                <section>
                    <div class="r-vstack r-stretch">
                        <h2>Closing Arguments</h2>
                        <h3>Against the Motion</h3>
                        <ul>
                            <li>Prompt engineering is not a programming language</li>
                            <li>It lacks formal syntax and semantics</li>
                            <li>Highly dependent on the underlying AI model</li>
                        </ul>
                    </div>
                    <aside class="notes">
                        Let’s bring together everything we’ve seen.
                        <br /><br />
                        Programming languages are defined by formal rules, predictable behavior, and composability.
                        Prompt engineering offers none of those. Instead, it works through suggestion, ambiguity, and
                        statistical inference.
                        <br /><br />
                        It doesn’t have strict syntax. It doesn’t guarantee repeatable results. It can’t be debugged in
                        the traditional sense. And critically — it depends entirely on the capabilities and quirks of
                        whatever model you’re targeting.
                        <br /><br />
                        This makes it powerful, yes — but not a language in the same sense as Python or Java. It’s a
                        tool for interfacing with systems that were designed to understand us, not to be programmed by
                        us.
                        <br /><br />
                        Call it communication, call it configuration — but don’t call it a programming language.
                    </aside>
                </section>

                <section>
                    <div class="r-vstack r-stretch">
                        <h2>Key Evidence Against</h2>
                        <ul>
                            <li>Inconsistent results across models</li>
                            <li>No compiler or formal verification</li>
                            <li>Rapid changes in best practices</li>
                            <li>Limited debugging capabilities</li>
                        </ul>
                    </div>
                    <aside class="notes">
                        Let’s leave you with some core reasons why prompt engineering, at least for now, can’t claim the
                        title of programming language:
                        <br /><br />

                        First: inconsistency. The exact same prompt can yield wildly different outputs across models —
                        or even from the same model at different times. It’s like asking a room full of interns to "just
                        do your best" and hoping you get identical answers.
                        <br /><br />

                        Second: no compiler, no static analysis, no formal specification. You don’t get compile-time
                        errors. You just get vibes. Forget red squiggles — the best you get is a polite hallucination.
                        <br /><br />

                        Third: it’s a moving target. Prompting best practices evolve faster than JavaScript frameworks.
                        What works great today might be obsolete next month — or behave totally differently in GPT-5.
                        <br /><br />

                        And finally: debugging. If your prompt doesn’t work, you don’t inspect stack traces — you
                        rewrite your sentence and hope for the best. It's not debugging — it’s trial by autocomplete.
                        <br /><br />

                        These aren’t characteristics of a programming language. They’re signs of an interface built on
                        interpretation — not structured logic.
                    </aside>
                </section>
            </section>

            <!-- Final Vote -->
            <section>
                <h2>Time to Vote</h2>
                <p>Has prompt engineering earned its place as the next programming language?</p>
                <button
                    style="font-size: 1.2em; padding: 10px; background-color: #ffcc00; border: none; border-radius: 5px; margin: 20px;">Cast
                    Your Vote</button>
                <aside class="notes">
                    <p>Marco: Drawing from Hien’s final thoughts: it might not be a full-fledged language yet, but it’s
                        definitely an emerging paradigm. Now, let’s see if you think the evolution will eventually cross
                        into “language” territory or remain a specialized skill.</p>
                </aside>
            </section>

            <!-- Final Slide: QR Code -->
            <section>
                <div class="r-vstack r-stretch">
                    <h2>Check out the slides?</h2>
                    <img src="assets/img/site-qr.svg" alt="QR Code to presentation"
                        style="width: 300px; height: 300px; margin: 20px auto;">
                    <p>Or on slack: </p>
                    <p><span style="color: aqua;">#topiconf-prompt-engineering</span> </p>
                </div>
                <aside class="notes">
                    <p>Encourage the audience to reflect on Hien’s viewpoint: is the future “programming via intention,”
                        or do we remain tethered to traditional programming structures? Ask for real-world experiences
                        with prompting to see how the group feels.</p>
                </aside>
            </section>

        </div>
    </div>

    <script src="https://unpkg.com/reveal.js@5.2.0/dist/reveal.js"></script>
    <script src="https://unpkg.com/reveal.js@5.2.0/plugin/notes/notes.js"></script>
    <script>
        Reveal.initialize({
            hash: true,
            plugins: [RevealNotes],
            preview: {
                enabled: true,
                fit: 'contain'
            }
        });

        // Progress indicator functionality
        document.body.setAttribute('data-section', 'intro'); // Default to intro section

        // Define slide index ranges for each section
        const sectionRanges = {
            intro: { start: 0, end: 4 },      // Slides 0-5: Introduction
            motion: { start: 5, end: 10 },      // Slides 6-7: The Motion
            syntax: { start: 11, end: 12 },      // Slides 8-9: Syntax and Structure sections
            knowledge: { start: 13, end: 14 },  // Slides 10-11: Knowledge and Skills sections
            impact: { start: 14, end: 16 },     // Slides 12-13: Impact and Longevity sections
            closing: { start: 17, end: 21 }     // Slides 14-17: Closing arguments and final vote
        };

        // Update the progress indicator based on current slide
        Reveal.on('slidechanged', event => {
            const indexh = Reveal.getIndices().h;

            // Determine which section the current slide belongs to
            for (const [section, range] of Object.entries(sectionRanges)) {
                if (indexh >= range.start && indexh <= range.end) {
                    document.body.setAttribute('data-section', section);
                    break;
                }
            }
        });
    </script>
</body>

</html>